<!DOCTYPE html>
<html lang="ko">
<head>
    <!-- 파비콘 및 외부 리소스 -->
    <link rel="icon" type="image/x-icon" href="/static/icon/favicon.ico">
    <link rel="apple-touch-icon" sizes="57x57" href="/static/icon/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/static/icon/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/static/icon/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/static/icon/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/static/icon/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/static/icon/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/static/icon/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/static/icon/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="167x167" href="/static/icon/apple-touch-icon-167x167.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/static/icon/apple-touch-icon-180x180.png">
    <!-- 기본 Apple Touch Icon -->
    <link rel="apple-touch-icon" href="/static/icon/apple-touch-icon.png">
    <!-- 추가 favicon 크기들 -->
    <link rel="icon" type="image/png" sizes="32x32" href="/static/icon/icon-32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/static/icon/icon-32.png">
    <!-- Windows 타일 -->
    <meta name="msapplication-TileImage" content="/static/icon/apple-touch-icon-144x144.png">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&family=Inter:wght@300;400;500;600;700&family=Noto+Sans+KR:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Prism.js CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <!-- Prism.js 툴바 플러그인 CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css">
    <!-- Mermaid.js CSS (테마 설정) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.css">
    <!-- 새로운 CSS 구조 -->
    <link rel="stylesheet" href="/static/css/main.css">
    
    <!-- 기본 메타 태그들 -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- Google Search Console 인증 메타 태그 -->
    {% if meta_tags.google_verification %}
    <meta name="google-site-verification" content="{{ meta_tags.google_verification }}" />
    {% endif %}
    
    <!-- SEO 메타 태그들 -->
    <title>{{ meta_tags.title }}</title>
    <meta name="description" content="{{ meta_tags.description }}">
    <meta name="keywords" content="{{ meta_tags.keywords }}">
    <meta name="author" content="{{ meta_tags.author }}">
    <meta name="robots" content="index, follow, max-image-preview:large">
    
    <!-- 정규 URL -->
    <link rel="canonical" href="{{ meta_tags.canonical_url }}">
    
    <!-- Open Graph 메타 태그들 -->
    <meta property="og:title" content="{{ meta_tags.og_title }}">
    <meta property="og:description" content="{{ meta_tags.og_description }}">
    <meta property="og:url" content="{{ meta_tags.og_url }}">
    <meta property="og:type" content="{{ meta_tags.og_type }}">
    <meta property="og:locale" content="{{ meta_tags.og_locale }}">
    <meta property="og:site_name" content="서정훈 백엔드 개발자 포트폴리오">
    
    <!-- Twitter 카드 메타 태그들 -->
    <meta name="twitter:card" content="{{ meta_tags.twitter_card }}">
    <meta name="twitter:title" content="{{ meta_tags.twitter_title }}">
    <meta name="twitter:description" content="{{ meta_tags.twitter_description }}">

    <!-- 구조화된 데이터 (JSON-LD) -->
    {% if meta_tags.structured_data %}
    <script type="application/ld+json">
    {{ meta_tags.structured_data | tojson }}
    </script>
    {% endif %}
    
    <!-- 브레드크럼 구조화된 데이터 -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BreadcrumbList",
        "itemListElement": [
            {
                "@type": "ListItem",
                "position": 1,
                "name": "백엔드 개발자 포트폴리오",
                "item": "https://cutwire.myddns.me/"
            },
            {
                "@type": "ListItem",
                "position": 2,
                "name": "{{ title }}",
                "item": "{{ meta_tags.og_url }}"
            }
        ]
    }
    </script>
</head>
<body>
    <!-- SEO 네비게이션 -->
    <nav class="seo-nav" aria-hidden="true" style="display:none;">
        <a href="/">백엔드 개발자 포트폴리오 홈</a> > 
        <span>{{ title }}</span>
    </nav>

    <div class="container">
        <main class="content">
            <!-- 프로젝트 헤더 -->
            <header class="project-header">
                <h1>{{ title }} - 백엔드 프로젝트</h1>
            </header>
            
            <div>
                <br>
                <br>
            </div>
            {{ content|safe }}

<!-- 복사 버튼은 Prism.js toolbar 플러그인이 자동으로 추가 -->
        </main>
    </div>

    <!-- Prism.js 코어 및 플러그인 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <!-- 툴바 플러그인 (복사 버튼의 기반) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
    <!-- 복사 기능 플러그인만 사용 (언어 라벨 플러그인 제거) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>
    
    <!-- Mermaid.js 라이브러리 -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    
    <!-- 모바일 최적화 스크립트 -->
    <script src="/static/js/mobile-fix.js"></script>
    <!-- 이메일 기능 스크립트 -->
    <script src="/static/js/modal-module.js"></script>
    
<script>
    // Mermaid 초기화 및 설정
    function initializeMermaid() {
        mermaid.initialize({
            startOnLoad: false,
            theme: 'dark',
            themeVariables: {
                primaryColor: '#6366f1',
                primaryTextColor: '#ffffff',
                primaryBorderColor: '#4f46e5',
                lineColor: '#64748b',
                sectionBkgColor: '#1e293b',
                altSectionBkgColor: '#0f172a',
                gridColor: '#374151',
                c0: '#6366f1',
                c1: '#8b5cf6',
                c2: '#06b6d4',
                c3: '#10b981',
                c4: '#f59e0b',
                c5: '#ef4444',
                c6: '#ec4899',
                c7: '#84cc16'
            },
            gantt: {
                titleTopMargin: 25,
                barHeight: 20,
                fontSize: 11,
                sectionFontSize: 24,
                gridLineStartPadding: 35,
                leftPadding: 75,
                topPadding: 50,
                rightPadding: 75,
                bottomPadding: 50
            }
        });
    }

    // Mermaid 코드 블록을 찾아서 렌더링
    async function renderMermaidCharts() {
        const mermaidBlocks = document.querySelectorAll('code.language-mermaid');
        
        for (let i = 0; i < mermaidBlocks.length; i++) {
            const block = mermaidBlocks[i];
            const pre = block.parentElement;
            const mermaidCode = block.textContent;
            
            try {
                // 고유 ID 생성
                const elementId = `mermaid-${Date.now()}-${i}`;
                
                // Mermaid 다이어그램을 렌더링할 div 생성
                const mermaidDiv = document.createElement('div');
                mermaidDiv.id = elementId;
                mermaidDiv.className = 'mermaid-chart';
                mermaidDiv.style.cssText = `
                    background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
                    border-radius: 12px;
                    padding: 20px;
                    margin: 20px 0;
                    border: 1px solid #374151;
                    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
                    overflow-x: auto;
                `;
                
                // 기존 pre 요소를 새로운 div로 교체
                pre.parentNode.replaceChild(mermaidDiv, pre);
                
                // Mermaid 렌더링 실행
                const { svg } = await mermaid.render(elementId + '-svg', mermaidCode);
                mermaidDiv.innerHTML = svg;
                
                // SVG 스타일 개선
                const svgElement = mermaidDiv.querySelector('svg');
                if (svgElement) {
                    svgElement.style.cssText = `
                        max-width: 100%;
                        height: auto;
                        font-family: 'Inter', 'Noto Sans KR', sans-serif;
                    `;
                    
                    // 반응형 처리를 위한 viewBox 설정
                    if (!svgElement.getAttribute('viewBox')) {
                        const width = svgElement.getAttribute('width');
                        const height = svgElement.getAttribute('height');
                        if (width && height) {
                            svgElement.setAttribute('viewBox', `0 0 ${width} ${height}`);
                            svgElement.removeAttribute('width');
                            svgElement.removeAttribute('height');
                        }
                    }
                }
                
                // 줌 기능 추가
                addZoomFunctionality(mermaidDiv);
                
            } catch (error) {
                console.error('Mermaid 렌더링 오류:', error);
                // 오류 발생시 원본 코드 블록 유지하고 오류 메시지 추가
                const errorDiv = document.createElement('div');
                errorDiv.style.cssText = `
                    background: #fef2f2;
                    border: 1px solid #fecaca;
                    border-radius: 8px;
                    padding: 12px;
                    margin: 10px 0;
                    color: #dc2626;
                `;
                errorDiv.innerHTML = `
                    <strong>Mermaid 차트 렌더링 오류:</strong><br>
                    ${error.message}
                `;
                pre.parentNode.insertBefore(errorDiv, pre);
            }
        }
    }

    // 차트 줌 기능 추가
    function addZoomFunctionality(chartContainer) {
        const zoomButton = document.createElement('button');
        zoomButton.innerHTML = '🔍 확대';
        zoomButton.style.cssText = `
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(99, 102, 241, 0.8);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 6px 12px;
            font-size: 12px;
            cursor: pointer;
            z-index: 10;
        `;
        
        // 컨테이너에 상대 위치 설정
        chartContainer.style.position = 'relative';
        chartContainer.appendChild(zoomButton);
        
        zoomButton.addEventListener('click', () => {
            // 모달로 확대된 차트 표시
            showChartModal(chartContainer.cloneNode(true));
        });
    }

    // 차트 모달 표시 함수
    function showChartModal(chartElement) {
        // 기존 모달이 있으면 제거
        const existingModal = document.querySelector('.chart-modal');
        if (existingModal) {
            existingModal.remove();
        }

        const modal = document.createElement('div');
        modal.className = 'chart-modal';
        modal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 20px;
        `;

        const modalContent = document.createElement('div');
        modalContent.style.cssText = `
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            border-radius: 12px;
            padding: 20px;
            max-width: 95vw;
            max-height: 95vh;
            overflow: auto;
            position: relative;
        `;

        const closeButton = document.createElement('button');
        closeButton.innerHTML = '✕';
        closeButton.style.cssText = `
            position: absolute;
            top: 10px;
            right: 10px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-size: 16px;
            z-index: 10;
        `;

        // 차트 복제본에서 줌 버튼 제거
        const zoomBtn = chartElement.querySelector('button');
        if (zoomBtn) zoomBtn.remove();

        modalContent.appendChild(closeButton);
        modalContent.appendChild(chartElement);
        modal.appendChild(modalContent);
        document.body.appendChild(modal);

        // 모달 닫기 이벤트
        closeButton.addEventListener('click', () => modal.remove());
        modal.addEventListener('click', (e) => {
            if (e.target === modal) modal.remove();
        });
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') modal.remove();
        });
    }

    // 언어 라벨을 수동으로 추가하는 함수 (CSS ::before로 표시)
    function addLanguageLabels() {
        document.querySelectorAll('pre code[class*="language-"]').forEach((codeElement) => {
            const pre = codeElement.parentElement;
            const className = codeElement.className;
            const match = className.match(/language-(\w+)/);
            
            if (match && !pre.hasAttribute('data-language') && match[1] !== 'mermaid') {
                const language = match[1].toUpperCase();
                pre.setAttribute('data-language', language);
                pre.classList.add(`language-${match[1]}`);
            }
        });
    }

    // GitHub API를 사용한 저장소 정보 가져오기
    async function fetchGitHubRepoInfo(owner, repo) {
        try {
            const response = await fetch(`https://api.github.com/repos/${owner}/${repo}`);
            if (response.ok) {
                const data = await response.json();
                return {
                    name: data.name,
                    description: data.description || 'GitHub 저장소에서 프로젝트 소스코드와 문서를 확인하세요',
                    language: data.language,
                    stars: data.stargazers_count,
                    forks: data.forks_count,
                    topics: data.topics || [],
                    updated: new Date(data.updated_at).toLocaleDateString('ko-KR'),
                    owner: data.owner.login,
                    fullName: data.full_name
                };
            }
        } catch (error) {
            console.log('GitHub API 호출 실패:', error);
        }
        return null;
    }

    // GitHub 링크 카드 변환 함수 (향상된 버전)
    async function convertGithubLinks() {
        const githubLinks = document.querySelectorAll('a[href*="github.com"]');
        
        for (const link of githubLinks) {
            const linkText = link.textContent.trim();
            if (linkText === 'github-link' || linkText.includes('github-link')) {
                // URL에서 프로젝트 정보 추출
                const url = link.href;
                const urlParts = url.split('/');
                const owner = urlParts[urlParts.length - 2];
                const repo = urlParts[urlParts.length - 1];
                
                // 새창으로 열리도록 속성 추가
                link.setAttribute('target', '_blank');
                link.setAttribute('rel', 'noopener noreferrer');
                
                // 로딩 상태 표시
                link.innerHTML = `
                    <div class="github-link-card-header">
                        <i class="fab fa-github github-link-card-icon"></i>
                        <span class="github-link-card-title">로딩 중...</span>
                    </div>
                    <div class="github-link-card-description">저장소 정보를 가져오는 중입니다...</div>
                    <div class="github-link-card-url">${url.replace('https://', '')}</div>
                `;
                link.classList.add('github-link-card');
                
                // GitHub API에서 실제 정보 가져오기
                const repoInfo = await fetchGitHubRepoInfo(owner, repo);
                
                if (repoInfo) {
                    // 실제 저장소 정보로 업데이트
                    link.innerHTML = `
                        <div class="github-link-card-header">
                            <div class="github-card-left">
                                <i class="fab fa-github github-link-card-icon"></i>
                                <span class="github-link-card-title">${repoInfo.name}</span>
                            </div>
                            <div class="github-link-card-stats">
                                ${repoInfo.language ? `<span class="repo-language">${repoInfo.language}</span>` : ''}
                                <span class="repo-stars">⭐ ${repoInfo.stars}</span>
                                <span class="repo-forks">🍴 ${repoInfo.forks}</span>
                            </div>
                        </div>
                        <div class="github-link-card-description">${repoInfo.description}</div>
                        ${repoInfo.topics.length > 0 ? `
                            <div class="github-link-card-topics">
                                ${repoInfo.topics.map(topic => `<span class="topic-tag">#${topic}</span>`).join('')}
                            </div>
                        ` : ''}
                        <div class="github-link-card-footer">
                            <div class="github-link-card-url">${url.replace('https://', '')}</div>
                            <div class="github-link-card-updated">최근 업데이트: ${repoInfo.updated}</div>
                        </div>
                        <div class="github-link-card-external">
                            <i class="fas fa-external-link-alt"></i>
                            <span>새창에서 열기</span>
                        </div>
                    `;
                } else {
                    // API 호출 실패시 기본 정보로 표시
                    link.innerHTML = `
                        <div class="github-link-card-header">
                            <div class="github-card-left">
                                <i class="fab fa-github github-link-card-icon"></i>
                                <span class="github-link-card-title">${repo}</span>
                            </div>
                        </div>
                        <div class="github-link-card-description">GitHub 저장소에서 프로젝트 소스코드와 문서를 확인하세요</div>
                        <div class="github-link-card-url">${url.replace('https://', '')}</div>
                        <div class="github-link-card-external">
                            <i class="fas fa-external-link-alt"></i>
                            <span>새창에서 열기</span>
                        </div>
                    `;
                }
            }
        }
    }

    document.addEventListener('DOMContentLoaded', async function () {
        // Mermaid 초기화
        initializeMermaid();
        
        // 이메일 컴포넌트 로드
        loadEmailComponent();
        
        // 언어 라벨 추가 (Mermaid 제외)
        addLanguageLabels();
        
        // GitHub 링크 카드 변환
        convertGithubLinks();
        
        // Mermaid 차트 렌더링 (Prism 하이라이팅 전에)
        await renderMermaidCharts();
        
        // Prism.js 하이라이팅 실행
        if (window.Prism) {
            Prism.highlightAll();
        }
        
        // 이미지 오버레이 기능
        const overlayContainer = document.createElement('div');
        overlayContainer.className = 'image-overlay-container';
        overlayContainer.innerHTML = `
            <button class="close-button">&times;</button>
            <img src="" alt="Overlay Image" draggable="false">
        `;
        document.body.appendChild(overlayContainer);

        const overlayImage = overlayContainer.querySelector('img');
        const closeButton = overlayContainer.querySelector('.close-button');

        let isZoomed = false;
        let isDragging = false;
        let startX = 0, startY = 0;
        let translateX = 0, translateY = 0;
        let initialDistance = 0;

        function preventTouchMove(e) {
            e.preventDefault();
        }

        function openOverlay() {
            overlayContainer.classList.add('active');
            document.body.style.overflow = 'hidden';
            window.addEventListener('touchmove', preventTouchMove, { passive: false });
        }

        function closeOverlay() {
            overlayContainer.classList.remove('active');
            document.body.style.overflow = '';
            window.removeEventListener('touchmove', preventTouchMove, { passive: false });
            resetImagePosition();
        }

        document.querySelectorAll('main.content img').forEach(img => {
            img.addEventListener('click', () => {
                overlayImage.src = img.src;
                openOverlay();
            });
        });

        closeButton.addEventListener('click', closeOverlay);

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeOverlay();
            }
        });

        overlayImage.addEventListener('dblclick', () => {
            toggleZoom();
        });

        overlayImage.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                startX = touch.clientX;
                startY = touch.clientY;
                isDragging = true;
            } else if (e.touches.length === 2) {
                initialDistance = getDistance(e.touches[0], e.touches[1]);
            }
        });

        overlayImage.addEventListener('touchmove', (e) => {
            if (isDragging && isZoomed && e.touches.length === 1) {
                const touch = e.touches[0];
                const deltaX = touch.clientX - startX;
                const deltaY = touch.clientY - startY;
                translateX += deltaX;
                translateY += deltaY;
                overlayImage.style.transform = `translate(${translateX}px, ${translateY}px) scale(3)`;
                startX = touch.clientX;
                startY = touch.clientY;
            } else if (e.touches.length === 2) {
                const currentDistance = getDistance(e.touches[0], e.touches[1]);
                if (currentDistance < initialDistance * 0.8) {
                    resetImagePosition();
                    isZoomed = false;
                }
            }
        });

        document.addEventListener('touchend', (e) => {
            if (e.touches.length === 0) {
                isDragging = false;
            }
        });

        overlayImage.addEventListener('mousedown', (e) => {
            if (isZoomed) {
                e.preventDefault();
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                overlayImage.style.cursor = 'grabbing';
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging && isZoomed) {
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                translateX += deltaX;
                translateY += deltaY;
                overlayImage.style.transform = `translate(${translateX}px, ${translateY}px) scale(3)`;
                startX = e.clientX;
                startY = e.clientY;
            }
        });

        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                overlayImage.style.cursor = 'grab';
            }
        });

        function toggleZoom() {
            if (isZoomed) {
                overlayImage.style.transform = 'translate(0, 0) scale(1)';
                isZoomed = false;
                resetImagePosition();
            } else {
                overlayImage.style.transform = 'scale(3)';
                isZoomed = true;
            }
        }

        function resetImagePosition() {
            translateX = 0;
            translateY = 0;
            overlayImage.style.transform = 'translate(0, 0) scale(1)';
        }

        function getDistance(touch1, touch2) {
            const deltaX = touch2.clientX - touch1.clientX;
            const deltaY = touch2.clientY - touch1.clientY;
            return Math.sqrt(deltaX * deltaX + deltaY * deltaX);
        }
    });
</script>
</body>
</html>